#include "versal.dtsh"
#include "versal/rpu.dtsh"

#define RPU_GIC_DIST 0x0
#define RPU_GIC_REDIST 0x100000
#define NUM_RPUS_PER_CLUSTER 2
#define FIRST_CPU_GIC(n) (NUM_APUS + n * NUM_RPUS_PER_CLUSTER)

#define TCM_CLUSTER(c, cpu0, cpu1)				\
	tcm_cluster_## c: tcm_cluster_## c@0 {			\
		#address-cells = <2>;				\
		#size-cells = <2>;				\
		#priority-cells = <1>;				\
		compatible = "qemu:memory-region";		\
		tcm_core_0 {					\
			compatible = "qemu:memory-region";	\
			alias = <&tcm_core## cpu0>;		\
			reg = <0x0 0x0 0x0 0x40000 0x0>;	\
		};						\
		tcm_core_1 {					\
			compatible = "qemu:memory-region";	\
			alias = <&tcm_core## cpu1>;		\
			reg = <0x0 0x40000 0x0 0x40000 0x0>;	\
		};						\
	};


#define TCM_CREATE(n)	\
	tcm_core ## n: tcm_core@ ## n {				\
		#address-cells = <2>;				\
		#size-cells = <2>;				\
		#priority-cells = <1>;				\
		compatible = "qemu:memory-region";		\
		MEM_REGION(atcm_rpu_core ## n, 0x0, 0x00000, 0x00000, 0x10000, &tcm_core ## n)	\
		MEM_REGION(btcm_rpu_core ## n, 0x0, 0x10000, 0x00000, 0x10000, &tcm_core ## n)	\
		MEM_REGION(ctcm_rpu_core ## n, 0x0, 0x20000, 0x00000, 0x10000, &tcm_core ## n)	\
	};

/*
 * GEN_RPU_CLUSTER(CLUSTER_ID, cluster_id, cluster_num, first_cpu_num, second_cpu_num)
 * ie: GEN_RPU_CLUSTER(A, a, 0, 0, 1);
 */
#define GEN_RPU_CLUSTER(u, c, n, f, s)						     \
		rpu_##c: rpu_##c@0 {						     \
			#address-cells = <1>;					     \
			#size-cells = <0>;					     \
			glue(rpu_cpu, f): rpu_cpu_##c@0 {			     \
				RPU_CPU_COMMON(f, n, 0);			     \
				core-count = <NUM_RPUS_PER_CLUSTER>;		     \
				gdb-id = STRINGIFY_EXPANDED(Cortex-R52 #glue(c, 0)); \
				gpios = < &crl glue(glue(CRL_RST_RPU_, u), _0)	     \
					&glue(glue(rpu_ctrl_, c), 0) 0 >;	     \
				gpio-names = "reset", "halt";			     \
				reset-cbar = <MM_RPU_GIC>;			     \
			};							     \
			glue(rpu_cpu, s): rpu_cpu_##c@1 {			     \
				RPU_CPU_COMMON(s, n, 1);			     \
				core-count = <NUM_RPUS_PER_CLUSTER>;		     \
				gdb-id = STRINGIFY_EXPANDED(Cortex-R52 #glue(c, 1)); \
				gpios = < &crl glue(glue(CRL_RST_RPU_, u), _1)	     \
					&glue(glue(rpu_ctrl_, c), 1) 0 >;	     \
				gpio-names = "reset", "halt";			     \
				reset-cbar = <MM_RPU_GIC>;			     \
			};							     \
		}

/*
 * GEN_RPU_GIC(cluster_id, cluster_num, first_cpu_num, second_cpu_num)
 * ie: GEN_RPU_GIC(a, 0, 0, 1);
 */
#define RPU_GIC(c, n, f, s)						     \
	glue(mr_rpu_gic_, c): glue(mr_rpu_gic_, c)@0 {			     \
		#address-cells = <2>;					     \
		#size-cells = <2>;					     \
		#priority-cells = <1>;					     \
		compatible = "simple-bus";				     \
									     \
		glue(rpu_gic_, c): glue(rpu_gic_, c)@RPU_GIC_DIST {	     \
			#address-cells = <0>;				     \
			#size-cells = <0>;				     \
			#interrupt-cells = <3>;				     \
									     \
			compatible = "arm-gicv3";			     \
			reg = < 0x0 RPU_GIC_DIST 0x0 0x10000 0		     \
				0x0 RPU_GIC_REDIST 0x0 0x40000 0>;	     \
			interrupt-controller ;				     \
			interrupts-extended =				     \
				/* IRQs.  */				     \
				<&glue(RPU_GIC_INTERRUPT_TARGET_STEM, f) 0>, \
				<&glue(RPU_GIC_INTERRUPT_TARGET_STEM, s) 0>, \
									     \
				/* FIQs.  */				     \
				<&glue(RPU_GIC_INTERRUPT_TARGET_STEM, f) 1>, \
				<&glue(RPU_GIC_INTERRUPT_TARGET_STEM, s) 1>, \
									     \
				/* Virtual IRQs.  */			     \
				<&glue(RPU_GIC_INTERRUPT_TARGET_STEM, f) 2>, \
				<&glue(RPU_GIC_INTERRUPT_TARGET_STEM, s) 2>, \
									     \
				/* Virtual FIQs.  */			     \
				<&glue(RPU_GIC_INTERRUPT_TARGET_STEM, f) 3>, \
				<&glue(RPU_GIC_INTERRUPT_TARGET_STEM, s) 3>, \
									     \
				<&glue(rpu_gic_, c) 0x1 0x9 0x104>,	     \
				<&glue(rpu_gic_, c) 0x1 0x9 0x204>;	     \
			first-cpu-idx = <FIRST_CPU_GIC(n)>;		     \
			num-cpu = <NUM_RPUS_PER_CLUSTER>;		     \
			num-irq = <256>;				     \
			redist-region-count = <NUM_RPUS_PER_CLUSTER>;	     \
		};							     \
	}

#define GEN_TIMER(c)							     \
		glue(timer_, c) {					     \
			compatible = "arm,armv8-timer";			     \
			interrupt-parent = <&glue(rpu_gic_, c)>;	     \
									     \
			/*						     \
			 * Cell[0]: 1 for connecting a PPI		     \
			 *						     \
			 * Cell[1]: PPI					     \
			 *						     \
			 * PPI	INTID					     \
			 * 14	30    Non-secure physical timer interrupt    \
			 * 11	27    Virtual timer interrupt		     \
			 * 10	26    Hypervisor timer interrupt	     \
			 *						     \
			 * Cell[2] bits[x:8]: mask with the CPUs to connect, \
			 * '3' connects GIC CPU0 and CPU1.		     \
			 *						     \
			 */						     \
			interrupts = <1 14 0x301>,			     \
				     <1 11 0x301>,			     \
				     <1 10 0x301>;			     \
			clock-frequency = <100000000>;			     \
		}

#define S_AXI_TCM_CONNECT(c, a)				\
	s_axi_tcm_## c: s_axi_tcm_## c@0 {		\
		compatible = "qemu:memory-region";	\
		alias = <&tcm_cluster_## c>;		\
		reg = <0x0 a 0x0 0x800000 0x0>;		\
	};

/ {
	cpus {
		GEN_RPU_CLUSTER(A, a, 0, 0, 1);
		GEN_RPU_CLUSTER(B, b, 1, 2, 3);
	};

	RPU_GIC(a, 0, 0, 1);
	RPU_GIC(b, 1, 2, 3);

	amba_rpu: amba_rpu@0 {
		GEN_TIMER(a);
		GEN_TIMER(b);
	};

	TCM_CREATE(0)
	TCM_CREATE(1)
	TCM_CREATE(2)
	TCM_CREATE(3)

	TCM_CLUSTER(a, 0, 1)
	TCM_CLUSTER(b, 2, 3)

	amba_r5_0: amba_r5@0 {
		downstream_tcm {
			compatible = "qemu:memory-region";
			alias = <&tcm_core0>;
			reg = <0x0 0x0 0x0 0x400000 0x1>;
		};
		downstream_gic0 {
			compatible = "qemu:memory-region";
			alias = <&mr_rpu_gic_a>;
			reg = <0x0 R5_GIC_DIST 0x0 0x140000 0x1>;
		};
	};

	amba_r5_1: amba_r5@1 {
		downstream_tcm {
			compatible = "qemu:memory-region";
			alias = <&tcm_core1>;
			reg = <0x0 0x0 0x0 0x400000 0x1>;
		};
		downstream_gic0 {
			compatible = "qemu:memory-region";
			alias = <&mr_rpu_gic_a>;
			reg = <0x0 R5_GIC_DIST 0x0 0x140000 0x1>;
		};
	};

	amba_r5_2: amba_r5@2 {
		#address-cells = <2>;
		#size-cells = <2>;
		#priority-cells = <1>;
		compatible = "simple-bus";
		ranges;

		downstream_tcm {
			compatible = "qemu:memory-region";
			alias = <&tcm_core2>;
			reg = <0x0 0x0 0x0 0x400000 0x1>;
		};
		downstream_gic1 {
			compatible = "qemu:memory-region";
			alias = <&mr_rpu_gic_b>;
			reg = <0x0 R5_GIC_DIST 0x0 0x140000 0x1>;
		};
		downstream_amba {
			compatible = "qemu:memory-region";
			alias = <&amba_rpu>;
			/* Full address range with 0 priority */
			reg = <0x0 0x0 0xffffffff 0xffffffff 0>;
		};
	};

	amba_r5_3: amba_r5@3 {
		#address-cells = <2>;
		#size-cells = <2>;
		#priority-cells = <1>;
		compatible = "simple-bus";
		ranges;

		downstream_tcm {
			compatible = "qemu:memory-region";
			alias = <&tcm_core3>;
			reg = <0x0 0x0 0x0 0x400000 0x1>;
		};
		downstream_gic1 {
			compatible = "qemu:memory-region";
			alias = <&mr_rpu_gic_b>;
			reg = <0x0 R5_GIC_DIST 0x0 0x140000 0x1>;
		};
		downstream_amba {
			compatible = "qemu:memory-region";
			alias = <&amba_rpu>;
			/* Full address range with 0 priority */
			reg = <0x0 0x0 0xffffffff 0xffffffff 0>;
		};
	};

	MEMATTR(rpu2_s, SECURE, SMID_RPU2);
	MEMATTR(rpu3_s, SECURE, SMID_RPU3);

};

&amba {
		S_AXI_TCM_CONNECT(a, MM_R52_0A_ATCM)
		S_AXI_TCM_CONNECT(b, MM_R52_0B_ATCM)
};

