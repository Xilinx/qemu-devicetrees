/*
 * Versal Gen 2 PSXC Shared Overlay.
 * This contains the overlay that's suitable for the both QEMU
 * instances in a multi-arch PSX/PMX setup.
 *
 * Copyright (c) 2023 Advanced Micro Devices Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <organization> nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#define CREATE_OCM_CTRL(n, addr_nm, size_nm, memsize_nm)       \
	glue(ocm_ctrl, n): ocm_ctrl@addr_nm {		       \
		compatible = "xlnx,zynqmp-ocmc";	       \
		interrupts = <glue(glue(OCM, n), INTR_IRQ_0)>; \
		memsize = <memsize_nm>;			       \
		reg = <0x0 addr_nm 0x0 size_nm 0x0>;	       \
		reset-gpios = <&crl glue(CRL_RST_OCM, n)>;     \
	}

&amba_lpd {
	CREATE_OCM_CTRL(1, MM_PSX_OCM1_REGS, MM_PSX_OCM1_REGS_SIZE,
			MM_OCM1_MEM_SIZE);
	CREATE_OCM_CTRL(2, MM_PSX_OCM2_REGS, MM_PSX_OCM2_REGS_SIZE,
			MM_OCM2_MEM_SIZE);
	CREATE_OCM_CTRL(3, MM_PSX_OCM3_REGS, MM_PSX_OCM3_REGS_SIZE,
			MM_OCM3_MEM_SIZE);
};

&amba_lpd {
	CREATE_CAN(2, MM_CANFD2, MM_CANFD2_SIZE);
	CREATE_CAN(3, MM_CANFD3, MM_CANFD3_SIZE);

	CREATE_TTC(4, MM_TTC4, MM_TTC4_SIZE);
	CREATE_TTC(5, MM_TTC5, MM_TTC5_SIZE);
	CREATE_TTC(6, MM_TTC6, MM_TTC6_SIZE);
	CREATE_TTC(7, MM_TTC7, MM_TTC7_SIZE);

	lpd_i2c_wrapper {
		CREATE_I2C_I3C(2, MM_PS_I2C_I3C2, MM_PS_I2C_I3C2_SIZE);
		CREATE_I2C_I3C(3, MM_PS_I2C_I3C3, MM_PS_I2C_I3C3_SIZE);
		CREATE_I2C_I3C(4, MM_PS_I2C_I3C4, MM_PS_I2C_I3C4_SIZE);
		CREATE_I2C_I3C(5, MM_PS_I2C_I3C5, MM_PS_I2C_I3C5_SIZE);
		CREATE_I2C_I3C(6, MM_PS_I2C_I3C6, MM_PS_I2C_I3C6_SIZE);
		CREATE_I2C_I3C(7, MM_PS_I2C_I3C7, MM_PS_I2C_I3C7_SIZE);
	};

	ZDMA_CHANNEL(sdma0, sdma, MM_SDMA_CH0, LPD_SDMA_IRQ_0, 128, &smmu_tbu0, SMID_SDMA_CH0, 8);
	ZDMA_CHANNEL(sdma1, sdma, MM_SDMA_CH1, LPD_SDMA_IRQ_1, 128, &smmu_tbu0, SMID_SDMA_CH1, 9);
	ZDMA_CHANNEL(sdma2, sdma, MM_SDMA_CH2, LPD_SDMA_IRQ_2, 128, &smmu_tbu0, SMID_SDMA_CH2, 10);
	ZDMA_CHANNEL(sdma3, sdma, MM_SDMA_CH3, LPD_SDMA_IRQ_3, 128, &smmu_tbu0, SMID_SDMA_CH3, 11);
	ZDMA_CHANNEL(sdma4, sdma, MM_SDMA_CH4, LPD_SDMA_IRQ_4, 128, &smmu_tbu0, SMID_SDMA_CH4, 12);
	ZDMA_CHANNEL(sdma5, sdma, MM_SDMA_CH5, LPD_SDMA_IRQ_5, 128, &smmu_tbu0, SMID_SDMA_CH5, 13);
	ZDMA_CHANNEL(sdma6, sdma, MM_SDMA_CH6, LPD_SDMA_IRQ_6, 128, &smmu_tbu0, SMID_SDMA_CH6, 14);
	ZDMA_CHANNEL(sdma7, sdma, MM_SDMA_CH7, LPD_SDMA_IRQ_7, 128, &smmu_tbu0, SMID_SDMA_CH7, 15);

	CREATE_LPD_WWDT(1, MM_LPD_WWDT1, MM_LPD_WWDT1_SIZE);
	/* FIXME: Four WWDT should be instantiated in LPD, but no reset line are
	 *        present at the moment.  Add them later.
	 * CREATE_LPD_WWDT(2, MM_LPD_WWDT2, MM_LPD_WWDT2_SIZE);
	 * CREATE_LPD_WWDT(3, MM_LPD_WWDT3, MM_LPD_WWDT3_SIZE);
	 */
        #ifdef CRL_RST_SWDT2
        #error "FIXME: WWDT device can now be instantiated."
        #endif
};

&crl {
	compatible = "xlnx,psxc_crl";
};

&lpd_slcr {
    compatible = "xlnx.psxc-lpx-slcr";
    interrupt-parent = <&pmc_ppu1_io_intc>;
    interrupts = <(16 + 14)>;
    #gpio-cells = <1>;
    gpio-controller;

#ifdef NUM_RPUS
    num-rpu = <NUM_RPUS>;

    /* P-Channel interface */
    core-0 = <&rpu_cpu0>;
    core-1 = <&rpu_cpu1>;
    core-2 = <&rpu_cpu2>;
    core-3 = <&rpu_cpu3>;
#if NUM_RPUS == 10
    core-4 = <&rpu_cpu4>;
    core-5 = <&rpu_cpu5>;
    core-6 = <&rpu_cpu6>;
    core-7 = <&rpu_cpu7>;
    core-8 = <&rpu_cpu8>;
    core-9 = <&rpu_cpu9>;
#endif
#endif
};

&amba_lpd {
    /* Included in the pscx-lpx-slcr */
    /delete-node/ rpu_pcil@0xEB420000;
};

&lpd_slcr_secure {
	compatible = "xlnx.versal2-psxc-lpx-slcr-secure";
};

#if NUM_APUS == 8
/*
 * 4 clusters, 2 cores per cluster. Core registers are sparse in the APU_PCIL
 * address space.
 */
# define APU_PCIL_NUM_CLUSTERS 4
# define APU_PCIL_CORE_MASK 0x3333

#elif NUM_APUS == 4
# define APU_PCIL_NUM_CLUSTERS 2
# define APU_PCIL_CORE_MASK 0x0033

#else
# error APU_PCIL: Please add support for this NUM_APUS
#endif

&apu_pcil {
    core-mask = <APU_PCIL_CORE_MASK>;
    cluster-mask = <((1 << APU_PCIL_NUM_CLUSTERS) - 1)>;

    gpios = <
        /* cluster 0-3 pchan power down */
        &lpd_slcr 82
        &lpd_slcr 83
#if APU_PCIL_NUM_CLUSTERS == 4
        &lpd_slcr 84
        &lpd_slcr 85
#endif

        /* cluster 0-3 pchan wakeup */
        &lpd_slcr 86
        &lpd_slcr 87
#if APU_PCIL_NUM_CLUSTERS == 4
        &lpd_slcr 88
        &lpd_slcr 89
#endif

        /* core 0-7 pchan power down */
        &lpd_slcr 90
        &lpd_slcr 91
        &lpd_slcr 92
        &lpd_slcr 93
#if NUM_APUS == 8
        &lpd_slcr 94
        &lpd_slcr 95
        &lpd_slcr 96
        &lpd_slcr 97
#endif

        /* core 0-7 pchan wakeup */
        &lpd_slcr 98
        &lpd_slcr 99
        &lpd_slcr 100
        &lpd_slcr 101
#if NUM_APUS == 8
        &lpd_slcr 102
        &lpd_slcr 103
        &lpd_slcr 104
        &lpd_slcr 105
#endif
    >;

    /* P-Channel interface */
    core-0 = <&cpu0>;
    core-1 = <&cpu1>;
    core-4 = <&cpu2>;
    core-5 = <&cpu3>;
#if NUM_APUS == 8
    core-8 = <&cpu4>;
    core-9 = <&cpu5>;
    core-12 = <&cpu6>;
    core-13 = <&cpu7>;
#endif
};

&amba {
	xmpu_ocm1: xmpu_ocm1@0 {
		compatible = "xlnx,versal-xmpu";
		interrupts = <XMPU_OCM_IRQ_0>;
		reg-extended = <
			&amba 0x0 MM_OCM1_XMPU 0x0 MM_OCM1_XMPU_SIZE 0x0
			&amba 0x0 MM_OCM1_MEM 0x0 MM_OCM1_MEM_SIZE 0x0
		>;
		protected-mr = <&ocm_mem>;
		mr-0 = <&amba>;
		protected-base = <MM_OCM1_MEM>;
	};
	xmpu_ocm2: xmpu_ocm2@0 {
		compatible = "xlnx,versal-xmpu";
		interrupts = <XMPU_OCM_IRQ_0>;
		reg-extended = <
			&amba 0x0 MM_OCM2_XMPU 0x0 MM_OCM2_XMPU_SIZE 0x0
			&amba 0x0 MM_OCM2_MEM 0x0 MM_OCM2_MEM_SIZE 0x0
		>;
		protected-mr = <&ocm_mem>;
		mr-0 = <&amba>;
		protected-base = <MM_OCM2_MEM>;
	};
	xmpu_ocm3: xmpu_ocm3@0 {
		compatible = "xlnx,versal-xmpu";
		interrupts = <XMPU_OCM_IRQ_0>;
		reg-extended = <
			&amba 0x0 MM_OCM3_XMPU 0x0 MM_OCM3_XMPU_SIZE 0x0
			&amba 0x0 MM_OCM3_MEM 0x0 MM_OCM3_MEM_SIZE 0x0
		>;
		protected-mr = <&ocm_mem>;
		mr-0 = <&amba>;
		protected-base = <MM_OCM3_MEM>;
	};
};
